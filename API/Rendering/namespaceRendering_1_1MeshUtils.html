<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Rendering: Rendering::MeshUtils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Rendering
   </div>
   <div id="projectbrief">Abstraction Layer for low-level graphics library (OpenGL, OpenGL ES 2.0)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRendering.html">Rendering</a></li><li class="navelem"><a class="el" href="namespaceRendering_1_1MeshUtils.html">MeshUtils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Rendering::MeshUtils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Operations on meshes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceRendering_1_1MeshUtils_1_1MarchingCubesMeshBuilder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils_1_1MarchingCubesMeshBuilder.html">MarchingCubesMeshBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRendering_1_1MeshUtils_1_1ConnectivityAccessor.html">ConnectivityAccessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRendering_1_1MeshUtils_1_1LocalMeshDataHolder.html">LocalMeshDataHolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to ensure that the data of a mesh stays in local memory.  <a href="classRendering_1_1MeshUtils_1_1LocalMeshDataHolder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRendering_1_1MeshUtils_1_1RawVertex.html">RawVertex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRendering_1_1MeshUtils_1_1SplitTriangle.html">SplitTriangle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRendering_1_1MeshUtils_1_1QuadtreeMeshBuilder.html">QuadtreeMeshBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRendering_1_1MeshUtils_1_1TriangleAccessor.html">TriangleAccessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abf6cb170c786414ac13c30afc557d6d7"><td class="memTemplParams" colspan="2"><a class="anchor" id="abf6cb170c786414ac13c30afc557d6d7"></a>
template&lt;typename GLType &gt; </td></tr>
<tr class="memitem:abf6cb170c786414ac13c30afc557d6d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interpolateValue</b> (uint8_t *data, const <a class="el" href="classRendering_1_1MeshUtils_1_1RawVertex.html">RawVertex</a> &amp;rwa, const <a class="el" href="classRendering_1_1MeshUtils_1_1RawVertex.html">RawVertex</a> &amp;rwb, const <a class="el" href="classRendering_1_1VertexAttribute.html">VertexAttribute</a> &amp;attr, unsigned j, float a, float a_inv)</td></tr>
<tr class="separator:abf6cb170c786414ac13c30afc557d6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0028cc9240e4ff8901bca5d7d9997c5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0028cc9240e4ff8901bca5d7d9997c5f"></a>
<a class="el" href="classGeometry_1_1__Sphere.html">Geometry::Sphere_f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a0028cc9240e4ff8901bca5d7d9997c5f">calculateBoundingSphere</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh)</td></tr>
<tr class="memdesc:a0028cc9240e4ff8901bca5d7d9997c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a tight bounding sphere for the vertex positions of the given mesh. <br/></td></tr>
<tr class="separator:a0028cc9240e4ff8901bca5d7d9997c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71757653cb53260773b2a63d3df23c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGeometry_1_1__Sphere.html">Geometry::Sphere_f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#aa71757653cb53260773b2a63d3df23c2">calculateBoundingSphere</a> (const std::vector&lt; std::pair&lt; <a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *, <a class="el" href="classGeometry_1_1__Matrix4x4.html">Geometry::Matrix4x4</a> &gt;&gt; &amp;meshesAndTransformations)</td></tr>
<tr class="separator:aa71757653cb53260773b2a63d3df23c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5504ee021f3ac74739503c584ed8347"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ab5504ee021f3ac74739503c584ed8347">calculateHash</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh)</td></tr>
<tr class="memdesc:ab5504ee021f3ac74739503c584ed8347"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#ab5504ee021f3ac74739503c584ed8347">More...</a><br/></td></tr>
<tr class="separator:ab5504ee021f3ac74739503c584ed8347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d71675ff41c9febeb70fdf943e3d5d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ab0d71675ff41c9febeb70fdf943e3d5d">calculateHash</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd)</td></tr>
<tr class="memdesc:ab0d71675ff41c9febeb70fdf943e3d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#ab0d71675ff41c9febeb70fdf943e3d5d">More...</a><br/></td></tr>
<tr class="separator:ab0d71675ff41c9febeb70fdf943e3d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bad9fa04fff0c30a4d506ff653fced7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a1bad9fa04fff0c30a4d506ff653fced7">compareMeshes</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh1, <a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh2)</td></tr>
<tr class="memdesc:a1bad9fa04fff0c30a4d506ff653fced7"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#a1bad9fa04fff0c30a4d506ff653fced7">More...</a><br/></td></tr>
<tr class="separator:a1bad9fa04fff0c30a4d506ff653fced7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300bc6f309a727483715ac260cfd3a5c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a300bc6f309a727483715ac260cfd3a5c">getLongestSideLength</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *m)</td></tr>
<tr class="separator:a300bc6f309a727483715ac260cfd3a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192b3d7509cae6ac85ade03de0fba043"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a192b3d7509cae6ac85ade03de0fba043">setMaterial</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, const Util::Color4f &amp;ambient, const Util::Color4f &amp;diffuse, const Util::Color4f &amp;, float)</td></tr>
<tr class="memdesc:a192b3d7509cae6ac85ade03de0fba043"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#a192b3d7509cae6ac85ade03de0fba043">More...</a><br/></td></tr>
<tr class="separator:a192b3d7509cae6ac85ade03de0fba043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdb7b9a052ac2b83c708d5cbf2a4e51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a1cdb7b9a052ac2b83c708d5cbf2a4e51">setColor</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, const Util::Color4f &amp;_color)</td></tr>
<tr class="memdesc:a1cdb7b9a052ac2b83c708d5cbf2a4e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#a1cdb7b9a052ac2b83c708d5cbf2a4e51">More...</a><br/></td></tr>
<tr class="separator:a1cdb7b9a052ac2b83c708d5cbf2a4e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515d912a1726ddf51b77069257f8c1ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a515d912a1726ddf51b77069257f8c1ed">splitLargeTriangles</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *m, float maxSideLength)</td></tr>
<tr class="memdesc:a515d912a1726ddf51b77069257f8c1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#a515d912a1726ddf51b77069257f8c1ed">More...</a><br/></td></tr>
<tr class="separator:a515d912a1726ddf51b77069257f8c1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0adaa82c3568022fb7fcd818a50d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a0f0adaa82c3568022fb7fcd818a50d72">shrinkMesh</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *m, bool shrinkPosition)</td></tr>
<tr class="memdesc:a0f0adaa82c3568022fb7fcd818a50d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#a0f0adaa82c3568022fb7fcd818a50d72">More...</a><br/></td></tr>
<tr class="separator:a0f0adaa82c3568022fb7fcd818a50d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb043b29a9df87557824b650fac0bf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#abfb043b29a9df87557824b650fac0bf0">transform</a> (<a class="el" href="classRendering_1_1MeshVertexData.html">MeshVertexData</a> &amp;vData, const <a class="el" href="classGeometry_1_1__Matrix4x4.html">Matrix4x4f</a> &amp;transMat)</td></tr>
<tr class="memdesc:abfb043b29a9df87557824b650fac0bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#abfb043b29a9df87557824b650fac0bf0">More...</a><br/></td></tr>
<tr class="separator:abfb043b29a9df87557824b650fac0bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b90a18ab819edfd7eebd85b7c06cb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a24b90a18ab819edfd7eebd85b7c06cb8">transformCoordinates</a> (<a class="el" href="classRendering_1_1MeshVertexData.html">MeshVertexData</a> &amp;vData, Util::StringIdentifier attrName, const <a class="el" href="classGeometry_1_1__Matrix4x4.html">Geometry::Matrix4x4</a> &amp;transMat, uint32_t begin, uint32_t numVerts)</td></tr>
<tr class="memdesc:a24b90a18ab819edfd7eebd85b7c06cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#a24b90a18ab819edfd7eebd85b7c06cb8">More...</a><br/></td></tr>
<tr class="separator:a24b90a18ab819edfd7eebd85b7c06cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a4bdb62108ec0af24b0d4b93b13e72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11a4bdb62108ec0af24b0d4b93b13e72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a11a4bdb62108ec0af24b0d4b93b13e72">transformNormals</a> (<a class="el" href="classRendering_1_1MeshVertexData.html">MeshVertexData</a> &amp;vData, Util::StringIdentifier attrName, const <a class="el" href="classGeometry_1_1__Matrix4x4.html">Geometry::Matrix4x4</a> &amp;transMat, uint32_t begin, uint32_t numVerts)</td></tr>
<tr class="memdesc:a11a4bdb62108ec0af24b0d4b93b13e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static) <br/></td></tr>
<tr class="separator:a11a4bdb62108ec0af24b0d4b93b13e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafb0ebb4d49cb94b6e054b31f930acf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adafb0ebb4d49cb94b6e054b31f930acf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>canConvert</b> (const <a class="el" href="classRendering_1_1VertexAttribute.html">VertexAttribute</a> &amp;oldAttr, const <a class="el" href="classRendering_1_1VertexAttribute.html">VertexAttribute</a> &amp;newAttr)</td></tr>
<tr class="separator:adafb0ebb4d49cb94b6e054b31f930acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c0b8a0979dbff1d31a8015bd60c098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1MeshVertexData.html">MeshVertexData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ab2c0b8a0979dbff1d31a8015bd60c098">convertVertices</a> (const <a class="el" href="classRendering_1_1MeshVertexData.html">MeshVertexData</a> &amp;oldVertices, const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;newVertexDescription)</td></tr>
<tr class="memdesc:ab2c0b8a0979dbff1d31a8015bd60c098"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#ab2c0b8a0979dbff1d31a8015bd60c098">More...</a><br/></td></tr>
<tr class="separator:ab2c0b8a0979dbff1d31a8015bd60c098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3755cd140e5d03830999d3f0baeb67c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ac3755cd140e5d03830999d3f0baeb67c">uniteVertexDescriptions</a> (const std::deque&lt; <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &gt; &amp;vertexDescs)</td></tr>
<tr class="separator:ac3755cd140e5d03830999d3f0baeb67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d2c04092e8cdcf06fa7299fc66a1f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a79d2c04092e8cdcf06fa7299fc66a1f0">removeColorData</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *m)</td></tr>
<tr class="memdesc:a79d2c04092e8cdcf06fa7299fc66a1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#a79d2c04092e8cdcf06fa7299fc66a1f0">More...</a><br/></td></tr>
<tr class="separator:a79d2c04092e8cdcf06fa7299fc66a1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127f6218cd45fe54a1185e1285f893d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a127f6218cd45fe54a1185e1285f893d1">calculateNormals</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *m)</td></tr>
<tr class="memdesc:a127f6218cd45fe54a1185e1285f893d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#a127f6218cd45fe54a1185e1285f893d1">More...</a><br/></td></tr>
<tr class="separator:a127f6218cd45fe54a1185e1285f893d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cea064f8c4170db443449e567cc869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a92cea064f8c4170db443449e567cc869">combineMeshes</a> (const std::deque&lt; <a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * &gt; &amp;meshArray)</td></tr>
<tr class="separator:a92cea064f8c4170db443449e567cc869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d951b9a94f36a679572167657b00177"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d951b9a94f36a679572167657b00177"></a>
<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>combineMeshes</b> (const std::deque&lt; <a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * &gt; &amp;meshArray, const std::deque&lt; <a class="el" href="classGeometry_1_1__Matrix4x4.html">Geometry::Matrix4x4</a> &gt; &amp;transformations)</td></tr>
<tr class="separator:a5d951b9a94f36a679572167657b00177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74792b5a5d9f3b307079351fd61d96a0"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="classRendering_1_1MeshVertexData.html">MeshVertexData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a74792b5a5d9f3b307079351fd61d96a0">splitVertexData</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, uint32_t chunkSize)</td></tr>
<tr class="separator:a74792b5a5d9f3b307079351fd61d96a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710c85b40d1fcd04bf748229840f97e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1MeshVertexData.html">MeshVertexData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a710c85b40d1fcd04bf748229840f97e4">extractVertexData</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, uint32_t begin, uint32_t length)</td></tr>
<tr class="separator:a710c85b40d1fcd04bf748229840f97e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6667024e1595f5b07f07885120181b66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a6667024e1595f5b07f07885120181b66">eliminateDuplicateVertices</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh)</td></tr>
<tr class="memdesc:a6667024e1595f5b07f07885120181b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#a6667024e1595f5b07f07885120181b66">More...</a><br/></td></tr>
<tr class="separator:a6667024e1595f5b07f07885120181b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25ea35285043c65f323cfdcb88a2f17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ad25ea35285043c65f323cfdcb88a2f17">eliminateUnusedVertices</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh)</td></tr>
<tr class="memdesc:ad25ea35285043c65f323cfdcb88a2f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#ad25ea35285043c65f323cfdcb88a2f17">More...</a><br/></td></tr>
<tr class="separator:ad25ea35285043c65f323cfdcb88a2f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b90a2bab24117ce45c9edaf601aa38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a78b90a2bab24117ce45c9edaf601aa38">eliminateLongTriangles</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, float ratio)</td></tr>
<tr class="memdesc:a78b90a2bab24117ce45c9edaf601aa38"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#a78b90a2bab24117ce45c9edaf601aa38">More...</a><br/></td></tr>
<tr class="separator:a78b90a2bab24117ce45c9edaf601aa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503aa64096c8790c7363112178127e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a503aa64096c8790c7363112178127e04">eliminateTrianglesBehindPlane</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, const <a class="el" href="classGeometry_1_1__Plane.html">Geometry::Plane</a> &amp;plane)</td></tr>
<tr class="separator:a503aa64096c8790c7363112178127e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b70017f02f988b6282342a4ae7ad08f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a8b70017f02f988b6282342a4ae7ad08f">eliminateZeroAreaTriangles</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh)</td></tr>
<tr class="separator:a8b70017f02f988b6282342a4ae7ad08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb823e3f32f3e353f5dac8c74005b201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#acb823e3f32f3e353f5dac8c74005b201">removeSkinsWithHoleCovering</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, float maxNormalZ, float coveringMovement)</td></tr>
<tr class="separator:acb823e3f32f3e353f5dac8c74005b201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff80752e72dbbac45a55e975ac328f82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#aff80752e72dbbac45a55e975ac328f82">optimizeIndices</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, const uint_fast8_t _cacheSize)</td></tr>
<tr class="separator:aff80752e72dbbac45a55e975ac328f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcd1ea7b19bd34f669ac1a7e7a33457"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a9dcd1ea7b19bd34f669ac1a7e7a33457">reverseWinding</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh)</td></tr>
<tr class="separator:a9dcd1ea7b19bd34f669ac1a7e7a33457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd646545bbc8d2875cbb053154a3700c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#abd646545bbc8d2875cbb053154a3700c">copyVertexAttribute</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, Util::StringIdentifier from, Util::StringIdentifier to)</td></tr>
<tr class="memdesc:abd646545bbc8d2875cbb053154a3700c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#abd646545bbc8d2875cbb053154a3700c">More...</a><br/></td></tr>
<tr class="separator:abd646545bbc8d2875cbb053154a3700c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c9cb1a610e9a529dfb204514d8740b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a81c9cb1a610e9a529dfb204514d8740b">calculateTextureCoordinates_projection</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, Util::StringIdentifier attribName, const <a class="el" href="classGeometry_1_1__Matrix4x4.html">Geometry::Matrix4x4</a> &amp;projection)</td></tr>
<tr class="memdesc:a81c9cb1a610e9a529dfb204514d8740b"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#a81c9cb1a610e9a529dfb204514d8740b">More...</a><br/></td></tr>
<tr class="separator:a81c9cb1a610e9a529dfb204514d8740b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ccbc7827fbf70dc6ce8c9b6e8534c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#aa7ccbc7827fbf70dc6ce8c9b6e8534c3">calculateTangentVectors</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, const Util::StringIdentifier uvName, const Util::StringIdentifier tangentVecName)</td></tr>
<tr class="memdesc:aa7ccbc7827fbf70dc6ce8c9b6e8534c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#aa7ccbc7827fbf70dc6ce8c9b6e8534c3">More...</a><br/></td></tr>
<tr class="separator:aa7ccbc7827fbf70dc6ce8c9b6e8534c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ade61aa34cfbb5514d7b5cb4cdcabc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ade61aa34cfbb5514d7b5cb4cdcabc4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isZero</b> (float f, float tolerance=std::numeric_limits&lt; float &gt;::epsilon())</td></tr>
<tr class="separator:a8ade61aa34cfbb5514d7b5cb4cdcabc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd6217b8751953238845c8a55452ae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a7cd6217b8751953238845c8a55452ae4">cutMesh</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *m, const <a class="el" href="classGeometry_1_1__Plane.html">Geometry::Plane</a> &amp;plane, const std::set&lt; uint32_t &gt; tIndices, float tolerance)</td></tr>
<tr class="memdesc:a7cd6217b8751953238845c8a55452ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#a7cd6217b8751953238845c8a55452ae4">More...</a><br/></td></tr>
<tr class="separator:a7cd6217b8751953238845c8a55452ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f2673851aaf559ff3da42b585d3950"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46f2673851aaf559ff3da42b585d3950"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>getAdjacence</b> (const <a class="el" href="classRendering_1_1MeshUtils_1_1SplitTriangle.html">SplitTriangle</a> &amp;t1, const <a class="el" href="classRendering_1_1MeshUtils_1_1SplitTriangle.html">SplitTriangle</a> &amp;t2, const <a class="el" href="classRendering_1_1VertexAttribute.html">VertexAttribute</a> &amp;posAttr)</td></tr>
<tr class="separator:a46f2673851aaf559ff3da42b585d3950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc92acfcc23bb4ecaf3723f51c595d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#adcc92acfcc23bb4ecaf3723f51c595d2">extrudeTriangles</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *m, const <a class="el" href="classGeometry_1_1__Vec3.html">Geometry::Vec3</a> &amp;dir, const std::set&lt; uint32_t &gt; tIndices)</td></tr>
<tr class="memdesc:adcc92acfcc23bb4ecaf3723f51c595d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#adcc92acfcc23bb4ecaf3723f51c595d2">More...</a><br/></td></tr>
<tr class="separator:adcc92acfcc23bb4ecaf3723f51c595d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f52d8ce06c36a89e9eef2f5d9add66"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#aa7f52d8ce06c36a89e9eef2f5d9add66">getFirstTriangleIntersectingRay</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *m, const <a class="el" href="classGeometry_1_1__Ray.html">Geometry::Ray3</a> &amp;ray)</td></tr>
<tr class="memdesc:aa7f52d8ce06c36a89e9eef2f5d9add66"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#aa7f52d8ce06c36a89e9eef2f5d9add66">More...</a><br/></td></tr>
<tr class="separator:aa7f52d8ce06c36a89e9eef2f5d9add66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18e1f3d99e4812f2a11b95dbb8e55f1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#aa18e1f3d99e4812f2a11b95dbb8e55f1">mergeCloseVertices</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, float tolerance)</td></tr>
<tr class="memdesc:aa18e1f3d99e4812f2a11b95dbb8e55f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">(static)  <a href="#aa18e1f3d99e4812f2a11b95dbb8e55f1">More...</a><br/></td></tr>
<tr class="separator:aa18e1f3d99e4812f2a11b95dbb8e55f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d89130bebd047c62ad7c80561666ba"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a84d89130bebd047c62ad7c80561666ba">splitIntoConnectedComponents</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, float relDistance)</td></tr>
<tr class="separator:a84d89130bebd047c62ad7c80561666ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1007989a110da1efc5e92d163a2a1cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ad1007989a110da1efc5e92d163a2a1cc">applyDisplacementMap</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, Util::PixelAccessor *displaceAcc, float scale, bool clampToEdge)</td></tr>
<tr class="separator:ad1007989a110da1efc5e92d163a2a1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f44194e88f8852d0a2f5692010455c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a78f44194e88f8852d0a2f5692010455c">applyNoise</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, float noiseScale, const <a class="el" href="classGeometry_1_1__Matrix4x4.html">Geometry::Matrix4x4</a> &amp;<a class="el" href="namespaceRendering_1_1MeshUtils.html#abfb043b29a9df87557824b650fac0bf0">transform</a>, uint32_t seed)</td></tr>
<tr class="separator:a78f44194e88f8852d0a2f5692010455c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37af463abde9234562387aa3198dc95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#aa37af463abde9234562387aa3198dc95">flattenMesh</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, const <a class="el" href="classGeometry_1_1__Vec3.html">Geometry::Vec3</a> &amp;pos, float radius, float falloff)</td></tr>
<tr class="separator:aa37af463abde9234562387aa3198dc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8e5f448e5ef3ae7257b149e7fd2c44"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#abe8e5f448e5ef3ae7257b149e7fd2c44">computeSurfaceArea</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh)</td></tr>
<tr class="separator:abe8e5f448e5ef3ae7257b149e7fd2c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ebb981d3ef49c8d8e0b893f8c198da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1MeshVertexData.html">MeshVertexData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a77ebb981d3ef49c8d8e0b893f8c198da">extractVertices</a> (<a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *mesh, const std::vector&lt; uint32_t &gt; &amp;indices)</td></tr>
<tr class="separator:a77ebb981d3ef49c8d8e0b893f8c198da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d7dc2ddb714ec8e8ab559c99086c5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ac1d7dc2ddb714ec8e8ab559c99086c5b">copyVertices</a> (<a class="el" href="classRendering_1_1Mesh.html">Rendering::Mesh</a> *source, <a class="el" href="classRendering_1_1Mesh.html">Rendering::Mesh</a> *target, uint32_t sourceOffset, uint32_t targetOffset, uint32_t count)</td></tr>
<tr class="separator:ac1d7dc2ddb714ec8e8ab559c99086c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2183404b9b165fe88049c25436357893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a2183404b9b165fe88049c25436357893">addBox</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, const <a class="el" href="classGeometry_1_1__Box.html">Geometry::Box</a> &amp;box)</td></tr>
<tr class="memdesc:a2183404b9b165fe88049c25436357893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a box to the given meshBuilder.  <a href="#a2183404b9b165fe88049c25436357893">More...</a><br/></td></tr>
<tr class="separator:a2183404b9b165fe88049c25436357893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b40e3ba2a270cd6f008f9663b2801f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a4b40e3ba2a270cd6f008f9663b2801f2">createBox</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, const <a class="el" href="classGeometry_1_1__Box.html">Geometry::Box</a> &amp;box)</td></tr>
<tr class="separator:a4b40e3ba2a270cd6f008f9663b2801f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebb186693c4bc52c27255eae776697a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#acebb186693c4bc52c27255eae776697a">addDome</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, const double radius=100.0, const int horiRes=40, const int vertRes=40, const double halfSphereFraction=1.0, const double imagePercentage=1.0)</td></tr>
<tr class="memdesc:acebb186693c4bc52c27255eae776697a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a dome to the given meshBuilder.  <a href="#acebb186693c4bc52c27255eae776697a">More...</a><br/></td></tr>
<tr class="separator:acebb186693c4bc52c27255eae776697a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c5948aa210083968c81b99c2bf9719"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ae5c5948aa210083968c81b99c2bf9719">createDome</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, const double radius, const int horiRes, const int vertRes, const double halfSphereFraction, const double imagePercentage)</td></tr>
<tr class="separator:ae5c5948aa210083968c81b99c2bf9719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917791c7db3b90fe0d0b91db7c0d67b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a917791c7db3b90fe0d0b91db7c0d67b8">addSphere</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, const <a class="el" href="classGeometry_1_1__Sphere.html">Geometry::Sphere_f</a> &amp;sphere, uint32_t inclinationSegments, uint32_t azimuthSegments)</td></tr>
<tr class="memdesc:a917791c7db3b90fe0d0b91db7c0d67b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a shere to the given meshBuilder.  <a href="#a917791c7db3b90fe0d0b91db7c0d67b8">More...</a><br/></td></tr>
<tr class="separator:a917791c7db3b90fe0d0b91db7c0d67b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a93bd38b07a030a51b1262173a9cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ad0a93bd38b07a030a51b1262173a9cbe">createSphere</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, const <a class="el" href="classGeometry_1_1__Sphere.html">Geometry::Sphere_f</a> &amp;sphere, uint32_t inclinationSegments, uint32_t azimuthSegments)</td></tr>
<tr class="separator:ad0a93bd38b07a030a51b1262173a9cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab152ac69a2ccdc484b7956f237b69909"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ab152ac69a2ccdc484b7956f237b69909">addDiscSector</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, float radius, uint8_t numSegments, float angle=360.0f)</td></tr>
<tr class="memdesc:ab152ac69a2ccdc484b7956f237b69909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a disc sector to the given meshBuilder.  <a href="#ab152ac69a2ccdc484b7956f237b69909">More...</a><br/></td></tr>
<tr class="separator:ab152ac69a2ccdc484b7956f237b69909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeccac1ea14ae11c17bf5ea770392041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#aeeccac1ea14ae11c17bf5ea770392041">createDiscSector</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, float radius, uint8_t numSegments, float angle)</td></tr>
<tr class="separator:aeeccac1ea14ae11c17bf5ea770392041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dec235ccb060799919c257d3330d576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a1dec235ccb060799919c257d3330d576">addRingSector</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, float innerRadius, float outerRadius, uint8_t numSegments, float angle=360.0f)</td></tr>
<tr class="memdesc:a1dec235ccb060799919c257d3330d576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a ring sector to the given meshBuilder.  <a href="#a1dec235ccb060799919c257d3330d576">More...</a><br/></td></tr>
<tr class="separator:a1dec235ccb060799919c257d3330d576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa354dbf0be329403dfea9ab9ffcfd431"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#aa354dbf0be329403dfea9ab9ffcfd431">createRingSector</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, float innerRadius, float outerRadius, uint8_t numSegments, float angle)</td></tr>
<tr class="separator:aa354dbf0be329403dfea9ab9ffcfd431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dcff2f904619df4fa969c0beab41c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ab6dcff2f904619df4fa969c0beab41c7">addCone</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, float radius, float height, uint8_t numSegments)</td></tr>
<tr class="memdesc:ab6dcff2f904619df4fa969c0beab41c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cone to the given meshBuilder.  <a href="#ab6dcff2f904619df4fa969c0beab41c7">More...</a><br/></td></tr>
<tr class="separator:ab6dcff2f904619df4fa969c0beab41c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2979072c0598ea665f4545c7d88ed18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ab2979072c0598ea665f4545c7d88ed18">createCone</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, float radius, float height, uint8_t numSegments)</td></tr>
<tr class="separator:ab2979072c0598ea665f4545c7d88ed18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f15408c4eeafc34316cfeb52684f7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#af9f15408c4eeafc34316cfeb52684f7c">addConicalFrustum</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, float radiusBottom, float radiusTop, float height, uint8_t numSegments)</td></tr>
<tr class="memdesc:af9f15408c4eeafc34316cfeb52684f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a conical frustum to the given meshBuilder.  <a href="#af9f15408c4eeafc34316cfeb52684f7c">More...</a><br/></td></tr>
<tr class="separator:af9f15408c4eeafc34316cfeb52684f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa379a195c5a13361dc09fef2b7494490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#aa379a195c5a13361dc09fef2b7494490">createConicalFrustum</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, float radiusBottom, float radiusTop, float height, uint8_t numSegments)</td></tr>
<tr class="separator:aa379a195c5a13361dc09fef2b7494490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ca2735dd9c6300781ff429eb2364d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ae8ca2735dd9c6300781ff429eb2364d3">addArrow</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, float radius, float length)</td></tr>
<tr class="memdesc:ae8ca2735dd9c6300781ff429eb2364d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an arrow to the given meshBuilder.  <a href="#ae8ca2735dd9c6300781ff429eb2364d3">More...</a><br/></td></tr>
<tr class="separator:ae8ca2735dd9c6300781ff429eb2364d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b2357cef11c8c3c289b33ba9ff223c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a41b2357cef11c8c3c289b33ba9ff223c">createArrow</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, float radius, float length)</td></tr>
<tr class="separator:a41b2357cef11c8c3c289b33ba9ff223c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773e516c509bd21ad601a2429da6979b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a773e516c509bd21ad601a2429da6979b">addRectangle</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, const <a class="el" href="classGeometry_1_1__Rect.html">Geometry::Rect_f</a> &amp;rect)</td></tr>
<tr class="memdesc:a773e516c509bd21ad601a2429da6979b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an rectangle to the given meshBuilder.  <a href="#a773e516c509bd21ad601a2429da6979b">More...</a><br/></td></tr>
<tr class="separator:a773e516c509bd21ad601a2429da6979b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858a5835e4f070a1d9c01e43785f7224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a858a5835e4f070a1d9c01e43785f7224">createRectangle</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, const <a class="el" href="classGeometry_1_1__Rect.html">Geometry::Rect_f</a> &amp;rect)</td></tr>
<tr class="separator:a858a5835e4f070a1d9c01e43785f7224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e261ae7b8df264a744afdf7bc4776cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a9e261ae7b8df264a744afdf7bc4776cd">addGrid</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, float width, float height, uint32_t rows, uint32_t columns)</td></tr>
<tr class="memdesc:a9e261ae7b8df264a744afdf7bc4776cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rectangular grid to the given meshBuilder.  <a href="#a9e261ae7b8df264a744afdf7bc4776cd">More...</a><br/></td></tr>
<tr class="separator:a9e261ae7b8df264a744afdf7bc4776cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ad13aa75fd22eb1488937c691af585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a15ad13aa75fd22eb1488937c691af585">createGrid</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, float width, float height, uint32_t rows, uint32_t columns)</td></tr>
<tr class="separator:a15ad13aa75fd22eb1488937c691af585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a47780cdc562f708890d4c2ef481c25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a1a47780cdc562f708890d4c2ef481c25">addHexGrid</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, float width, float height, uint32_t rows, uint32_t columns)</td></tr>
<tr class="memdesc:a1a47780cdc562f708890d4c2ef481c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a hexagonal grid to the given meshBuilder.  <a href="#a1a47780cdc562f708890d4c2ef481c25">More...</a><br/></td></tr>
<tr class="separator:a1a47780cdc562f708890d4c2ef481c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e60b2bd65989ad49efb0a9574ae58c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#aa4e60b2bd65989ad49efb0a9574ae58c">createHexGrid</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, float width, float height, uint32_t rows, uint32_t columns)</td></tr>
<tr class="separator:aa4e60b2bd65989ad49efb0a9574ae58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df2ec6de94e282247d1d1b1d4a57f0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a3df2ec6de94e282247d1d1b1d4a57f0a">addVoxelMesh</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, const Util::PixelAccessor &amp;colorAcc, uint32_t depth)</td></tr>
<tr class="memdesc:a3df2ec6de94e282247d1d1b1d4a57f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a voxel mesh to the given meshBuilder.  <a href="#a3df2ec6de94e282247d1d1b1d4a57f0a">More...</a><br/></td></tr>
<tr class="separator:a3df2ec6de94e282247d1d1b1d4a57f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d2a16dc47b680198fd058ccc14202a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a53d2a16dc47b680198fd058ccc14202a">createVoxelMesh</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, const Util::PixelAccessor &amp;colorAcc, uint32_t depth)</td></tr>
<tr class="separator:a53d2a16dc47b680198fd058ccc14202a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af356cac848a1a3e0182f42a87fbc0192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#af356cac848a1a3e0182f42a87fbc0192">addTorus</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, float innerRadius, float outerRadius, uint32_t majorSegments, uint32_t minorSegments)</td></tr>
<tr class="memdesc:af356cac848a1a3e0182f42a87fbc0192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a torus to the <a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a>.  <a href="#af356cac848a1a3e0182f42a87fbc0192">More...</a><br/></td></tr>
<tr class="separator:af356cac848a1a3e0182f42a87fbc0192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadf25f0c8138e4a6935841c8d1c1631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#adadf25f0c8138e4a6935841c8d1c1631">createTorus</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, float innerRadius, float outerRadius, uint32_t majorSegments, uint32_t minorSegments)</td></tr>
<tr class="separator:adadf25f0c8138e4a6935841c8d1c1631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51c1e1e2e575c79940a2c0fd4fc36d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ae51c1e1e2e575c79940a2c0fd4fc36d2">addMeshFromBitmaps</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, Util::Reference&lt; Util::PixelAccessor &gt; depth, Util::Reference&lt; Util::PixelAccessor &gt; color, Util::Reference&lt; Util::PixelAccessor &gt; normals)</td></tr>
<tr class="memdesc:ae51c1e1e2e575c79940a2c0fd4fc36d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a mesh from bitmap to the given meshBuilder.  <a href="#ae51c1e1e2e575c79940a2c0fd4fc36d2">More...</a><br/></td></tr>
<tr class="separator:ae51c1e1e2e575c79940a2c0fd4fc36d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159456c04d5423605fdb561ec38a4473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a159456c04d5423605fdb561ec38a4473">createMeshFromBitmaps</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, Util::Reference&lt; Util::PixelAccessor &gt; depth, Util::Reference&lt; Util::PixelAccessor &gt; color, Util::Reference&lt; Util::PixelAccessor &gt; normals)</td></tr>
<tr class="separator:a159456c04d5423605fdb561ec38a4473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80567e5cbd0318a3c08a10054d963b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#ab80567e5cbd0318a3c08a10054d963b0">createRectangle</a> (const <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> &amp;vd, float width, float height)</td></tr>
<tr class="separator:ab80567e5cbd0318a3c08a10054d963b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892c342c01b71b7e44909bf58e6198c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRendering_1_1MeshUtils.html#a892c342c01b71b7e44909bf58e6198c8">addRectangle</a> (<a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a> &amp;mb, float width, float height)</td></tr>
<tr class="memdesc:a892c342c01b71b7e44909bf58e6198c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an rectangle to the given meshBuilder.  <a href="#a892c342c01b71b7e44909bf58e6198c8">More...</a><br/></td></tr>
<tr class="separator:a892c342c01b71b7e44909bf58e6198c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Operations on meshes. </p>
<p>Functions and classes for the creation (e.g. <a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshUtils::MeshBuilder</a>) or modification (e.g. <a class="el" href="namespaceRendering_1_1MeshUtils.html#a127f6218cd45fe54a1185e1285f893d1" title="(static) ">MeshUtils::calculateNormals</a>) of meshes.</p>
<dl class="section author"><dt>Author</dt><dd>Claudius Jaehn </dd>
<dd>
Ralf Petring </dd>
<dd>
Benjamin Eikel </dd>
<dd>
Stefan Arens </dd>
<dd>
Paul Justus </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae8ca2735dd9c6300781ff429eb2364d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addArrow </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an arrow to the given meshBuilder. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#a41b2357cef11c8c3c289b33ba9ff223c">createArrow</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="a2183404b9b165fe88049c25436357893"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addBox </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Box.html">Geometry::Box</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a box to the given meshBuilder. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#a4b40e3ba2a270cd6f008f9663b2801f2">createBox</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="ab6dcff2f904619df4fa969c0beab41c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addCone </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numSegments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cone to the given meshBuilder. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#ab2979072c0598ea665f4545c7d88ed18">createCone</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="af9f15408c4eeafc34316cfeb52684f7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addConicalFrustum </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radiusBottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radiusTop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numSegments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a conical frustum to the given meshBuilder. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#aa379a195c5a13361dc09fef2b7494490">createConicalFrustum</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="ab152ac69a2ccdc484b7956f237b69909"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addDiscSector </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em> = <code>360.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a disc sector to the given meshBuilder. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#aeeccac1ea14ae11c17bf5ea770392041">createDiscSector</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="acebb186693c4bc52c27255eae776697a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addDome </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>100.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>horiRes</em> = <code>40</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>vertRes</em> = <code>40</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>halfSphereFraction</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>imagePercentage</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a dome to the given meshBuilder. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#ae5c5948aa210083968c81b99c2bf9719">createDome</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="a9e261ae7b8df264a744afdf7bc4776cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addGrid </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a rectangular grid to the given meshBuilder. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#a15ad13aa75fd22eb1488937c691af585">createGrid</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="a1a47780cdc562f708890d4c2ef481c25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addHexGrid </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a hexagonal grid to the given meshBuilder. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#aa4e60b2bd65989ad49efb0a9574ae58c">createHexGrid</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="ae51c1e1e2e575c79940a2c0fd4fc36d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addMeshFromBitmaps </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Util::Reference&lt; Util::PixelAccessor &gt;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Util::Reference&lt; Util::PixelAccessor &gt;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Util::Reference&lt; Util::PixelAccessor &gt;&#160;</td>
          <td class="paramname"><em>normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a mesh from bitmap to the given meshBuilder. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#a159456c04d5423605fdb561ec38a4473">createMeshFromBitmaps</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="a892c342c01b71b7e44909bf58e6198c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addRectangle </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an rectangle to the given meshBuilder. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#a858a5835e4f070a1d9c01e43785f7224">createRectangle</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="a773e516c509bd21ad601a2429da6979b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addRectangle </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Rect.html">Geometry::Rect_f</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an rectangle to the given meshBuilder. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#a858a5835e4f070a1d9c01e43785f7224">createRectangle</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="a1dec235ccb060799919c257d3330d576"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addRingSector </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>innerRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>outerRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em> = <code>360.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a ring sector to the given meshBuilder. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#aa354dbf0be329403dfea9ab9ffcfd431">createRingSector</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="a917791c7db3b90fe0d0b91db7c0d67b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addSphere </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Sphere.html">Geometry::Sphere_f</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inclinationSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>azimuthSegments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a shere to the given meshBuilder. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#ad0a93bd38b07a030a51b1262173a9cbe">createSphere</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="af356cac848a1a3e0182f42a87fbc0192"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addTorus </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>innerRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>outerRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>majorSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>minorSegments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a torus to the <a class="el" href="classRendering_1_1MeshUtils_1_1MeshBuilder.html">MeshBuilder</a>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#af356cac848a1a3e0182f42a87fbc0192" title="Adds a torus to the MeshBuilder. ">addTorus</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="a3df2ec6de94e282247d1d1b1d4a57f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::addVoxelMesh </td>
          <td>(</td>
          <td class="paramtype">MeshBuilder &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Util::PixelAccessor &amp;&#160;</td>
          <td class="paramname"><em>colorAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a voxel mesh to the given meshBuilder. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceRendering_1_1MeshUtils.html#aa4e60b2bd65989ad49efb0a9574ae58c">createHexGrid</a>(...) </dd></dl>

</div>
</div>
<a class="anchor" id="ad1007989a110da1efc5e92d163a2a1cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::applyDisplacementMap </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Util::PixelAccessor *&#160;</td>
          <td class="paramname"><em>displaceAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clampToEdge</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves every vertex along their normal according to the given texture (using its u,v coordinates).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramname">displaceAcc</td><td>pixel accessor of the displacement map </td></tr>
    <tr><td class="paramname">scale</td><td>scale factor multiplied with the value of the texture </td></tr>
    <tr><td class="paramname">clampToEdge</td><td>clamp to texture borders (true) or wrap around (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Sascha Brandt </dd></dl>

</div>
</div>
<a class="anchor" id="a78f44194e88f8852d0a2f5692010455c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::applyNoise </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noiseScale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Matrix4x4.html">Geometry::Matrix4x4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves every vertex along their normal using the value of a 3D perlin noise function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramname">seed</td><td>The seed for the noise generator </td></tr>
    <tr><td class="paramname">noiseScale</td><td>scale factor multiplied with the noise value </td></tr>
    <tr><td class="paramname">transform</td><td>transformation matrix applied on each position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Sascha Brandt </dd></dl>

</div>
</div>
<a class="anchor" id="aa71757653cb53260773b2a63d3df23c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGeometry_1_1__Sphere.html">Geometry::Sphere_f</a> Rendering::MeshUtils::calculateBoundingSphere </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; Mesh *, <a class="el" href="classGeometry_1_1__Matrix4x4.html">Geometry::Matrix4x4</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>meshesAndTransformations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a tight bounding sphere for the vertex positions of the given meshes after applying the corresponding transformations to the positions. </p>

</div>
</div>
<a class="anchor" id="ab5504ee021f3ac74739503c584ed8347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Rendering::MeshUtils::calculateHash </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Calculate a hash value for the given mesh. </p>

</div>
</div>
<a class="anchor" id="ab0d71675ff41c9febeb70fdf943e3d5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Rendering::MeshUtils::calculateHash </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Calculate a hash value for the given vertex description. </p>

</div>
</div>
<a class="anchor" id="a127f6218cd45fe54a1185e1285f893d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::calculateNormals </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>calulates vertex normals for a given mesh calculation is done by</p>
<ul>
<li>first calculating face normals</li>
<li>second calculating the unweighted average of the adjacent face normals for all vertices <dl class="section note"><dt>Note</dt><dd>if the mesh has already normals these are ignored and recalculated </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh to be modified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ralf Petring </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="aa7ccbc7827fbf70dc6ce8c9b6e8534c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::calculateTangentVectors </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Util::StringIdentifier&#160;</td>
          <td class="paramname"><em>uvName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Util::StringIdentifier&#160;</td>
          <td class="paramname"><em>tangentVecName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Calculate and add tangent space vectors from the normals and uv-coordinates of the given mesh. </p>
<dl class="section note"><dt>Note</dt><dd>based on: Lengyel, Eric. "Computing Tangent Space Basis Vectors for an Arbitrary Mesh". Terathon Software 3D Graphics Library, 2001. <a href="http://www.terathon.com/code/tangent.html">http://www.terathon.com/code/tangent.html</a> The bitangent can be calculated in the shader by: float3 bitangent = cross(normal, tangent.xyz) * tangent.w; </dd></dl>

</div>
</div>
<a class="anchor" id="a81c9cb1a610e9a529dfb204514d8740b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::calculateTextureCoordinates_projection </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Util::StringIdentifier&#160;</td>
          <td class="paramname"><em>attribName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Matrix4x4.html">Geometry::Matrix4x4</a> &amp;&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Create texture coordinates by projecting the vertices with the given projection matrix. </p>

</div>
</div>
<a class="anchor" id="a92cea064f8c4170db443449e567cc869"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::combineMeshes </td>
          <td>(</td>
          <td class="paramtype">const std::deque&lt; Mesh * &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[static] Combines the meshes from meshArray to a single mesh. Must have identical <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a>.</p>
<p>Combine several meshes into a single mesh.</p>
<dl class="section note"><dt>Note</dt><dd>All meshes must have the same <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a>. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Claudius Jaehn </dd>
<dd>
Stefan Arens </dd>
<dd>
Paul Justus </dd></dl>

</div>
</div>
<a class="anchor" id="a1bad9fa04fff0c30a4d506ff653fced7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rendering::MeshUtils::compareMeshes </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Return <code>true</code> iff the given two meshes contain the same data - only the glIds and the filenames are not compared. </p>

</div>
</div>
<a class="anchor" id="abe8e5f448e5ef3ae7257b149e7fd2c44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Rendering::MeshUtils::computeSurfaceArea </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the combined surface area of all triangles in a mesh</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the surface area </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Sascha Brandt </dd></dl>

</div>
</div>
<a class="anchor" id="ab2c0b8a0979dbff1d31a8015bd60c098"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1MeshVertexData.html">MeshVertexData</a> * Rendering::MeshUtils::convertVertices </td>
          <td>(</td>
          <td class="paramtype">const MeshVertexData &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>newVertexDescription</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>allocates the memory for storing old vertices in new format and copies the old values to the correct position in the new memory </p>
<dl class="section note"><dt>Note</dt><dd>missing values are initialized with 0 </dd>
<dd>
values which do not fit into the new format get lost </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ralf Petring </dd></dl>

</div>
</div>
<a class="anchor" id="abd646545bbc8d2875cbb053154a3700c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::copyVertexAttribute </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Util::StringIdentifier&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Util::StringIdentifier&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Copy data from one vertex attribute to another. Create, or modify the target attribute. </p>

</div>
</div>
<a class="anchor" id="ac1d7dc2ddb714ec8e8ab559c99086c5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::copyVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRendering_1_1Mesh.html">Rendering::Mesh</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRendering_1_1Mesh.html">Rendering::Mesh</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sourceOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>targetOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies vertices from one mesh to another. If both meshes are uploaded, it directly copies using the buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> to copy vertices from </td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> to copy vertices to </td></tr>
    <tr><td class="paramname">sourceOffset</td><td>vertex offset of the source mesh </td></tr>
    <tr><td class="paramname">targetOffset</td><td>vertex offset of the target mesh </td></tr>
    <tr><td class="paramname">count</td><td>number of vertices to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Sascha Brandt </dd></dl>

</div>
</div>
<a class="anchor" id="a41b2357cef11c8c3c289b33ba9ff223c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::createArrow </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an arrow which consists of a ConicalFrustum and 2 Cones at one end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td><a class="el" href="structRendering_1_1Vertex.html">Vertex</a> description specifying the vertex information to generate </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the arrow </td></tr>
    <tr><td class="paramname">length</td><td>Overall length of the arrow </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Arrow <a class="el" href="classRendering_1_1Mesh.html">Mesh</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4b40e3ba2a270cd6f008f9663b2801f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::createBox </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Box.html">Geometry::Box</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the mesh of a three-dimensional, axis-aligned box. Positions, and normals are supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td><a class="el" href="structRendering_1_1Vertex.html">Vertex</a> description specifying the vertex information to generate </td></tr>
    <tr><td class="paramname">box</td><td>Geometric specification of the box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> of the box </dd></dl>

</div>
</div>
<a class="anchor" id="ab2979072c0598ea665f4545c7d88ed18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::createCone </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numSegments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a cone with the radius given. The cap end is not created. The center of the base is the origin. The apex lies on the x-axis at distance <em>height</em> from the origin. Positions and normals for the vertices are generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td><a class="el" href="structRendering_1_1Vertex.html">Vertex</a> description specifying the vertex information to generate </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the base </td></tr>
    <tr><td class="paramname">height</td><td>Distance between the base and the apex </td></tr>
    <tr><td class="paramname">numSegments</td><td>Number of segments for the circle at the base and the lateral surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cone <a class="el" href="classRendering_1_1Mesh.html">Mesh</a> or <code>nullptr</code> if the number of segments is smaller than two </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>createDisc() for creation of a cap end </dd></dl>

</div>
</div>
<a class="anchor" id="aa379a195c5a13361dc09fef2b7494490"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::createConicalFrustum </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radiusBottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radiusTop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numSegments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a conical frustum with the radii given. The cap ends are not created. The center of the bottom circle is the origin. The center of the top circle lies on the x-axis at distance <em>height</em> from the origin. If both radii have the same value, a cylinder is created. Positions and normals for the vertices are generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td><a class="el" href="structRendering_1_1Vertex.html">Vertex</a> description specifying the vertex information to generate </td></tr>
    <tr><td class="paramname">radiusBottom</td><td>Radius of the bottom circle </td></tr>
    <tr><td class="paramname">radiusTop</td><td>Radius of the top circle </td></tr>
    <tr><td class="paramname">height</td><td>Distance between both circles </td></tr>
    <tr><td class="paramname">numSegments</td><td>Number of segments for the circles and the lateral surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Conical frustum <a class="el" href="classRendering_1_1Mesh.html">Mesh</a> or <code>nullptr</code> if the number of segments is smaller than two </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>createDisc() for creation of cap ends </dd></dl>

</div>
</div>
<a class="anchor" id="aeeccac1ea14ae11c17bf5ea770392041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::createDiscSector </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em> = <code>360.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a sector of a disc. The center of the disc is the origin. The disc is aligned with the y-z plane and the normals are pointing into negative x direction. Positions and normals for the vertices are generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td><a class="el" href="structRendering_1_1Vertex.html">Vertex</a> description specifying the vertex information to generate </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the disc </td></tr>
    <tr><td class="paramname">numSegments</td><td>Number of segments for the disc </td></tr>
    <tr><td class="paramname">angle</td><td>Central angle of the sector in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Disc <a class="el" href="classRendering_1_1Mesh.html">Mesh</a> or <code>nullptr</code> if the number of segments is smaller than two. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5c5948aa210083968c81b99c2bf9719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::createDome </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>100.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>horiRes</em> = <code>40</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>vertRes</em> = <code>40</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>halfSphereFraction</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>imagePercentage</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a mesh for a sky dome with texture coordinates. </p>
<dl class="section note"><dt>Note</dt><dd>adapted from [alc] <a href="http://irrlicht.sourceforge.net/phpBB2/viewtopic.php?t=13887&sid=25788d2b93c73294fd7abe76db6fab1e">http://irrlicht.sourceforge.net/phpBB2/viewtopic.php?t=13887&amp;sid=25788d2b93c73294fd7abe76db6fab1e</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a15ad13aa75fd22eb1488937c691af585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::createGrid </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a rectangular grid in the x-z-plane.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td><a class="el" href="structRendering_1_1Vertex.html">Vertex</a> description specifying the vertex information to generate </td></tr>
    <tr><td class="paramname">width</td><td>The width of the grid </td></tr>
    <tr><td class="paramname">height</td><td>The height of the grid </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows </td></tr>
    <tr><td class="paramname">columns</td><td>number of columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4e60b2bd65989ad49efb0a9574ae58c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::createHexGrid </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a hexagonal grid in the x-z-plane.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td><a class="el" href="structRendering_1_1Vertex.html">Vertex</a> description specifying the vertex information to generate </td></tr>
    <tr><td class="paramname">width</td><td>The width of the grid </td></tr>
    <tr><td class="paramname">height</td><td>The height of the grid </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows. Needs to be at least 3 </td></tr>
    <tr><td class="paramname">columns</td><td>number of columns. Needs to be at least 4 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a159456c04d5423605fdb561ec38a4473"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::createMeshFromBitmaps </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Util::Reference&lt; Util::PixelAccessor &gt;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Util::Reference&lt; Util::PixelAccessor &gt;&#160;</td>
          <td class="paramname"><em>color</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Util::Reference&lt; Util::PixelAccessor &gt;&#160;</td>
          <td class="paramname"><em>normals</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a mesh from the input bitmap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td><a class="el" href="structRendering_1_1Vertex.html">Vertex</a> description specifying the vertex information to generate </td></tr>
    <tr><td class="paramname">depth</td><td>Bitmap with depth values. Translates to the y-values of the mesh. </td></tr>
    <tr><td class="paramname">color</td><td>Bitmap with colors. </td></tr>
    <tr><td class="paramname">normals</td><td>Bitmap with normals. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mesh </dd></dl>

</div>
</div>
<a class="anchor" id="ab80567e5cbd0318a3c08a10054d963b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a>* Rendering::MeshUtils::createRectangle </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a Rectangle consisting of 2 triangles with origin in the center (oriented in x-y-plane)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td><a class="el" href="structRendering_1_1Vertex.html">Vertex</a> description specifying the vertex information to generate </td></tr>
    <tr><td class="paramname">width</td><td>The width of the rectangle </td></tr>
    <tr><td class="paramname">height</td><td>The height of the rectangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rectangle <a class="el" href="classRendering_1_1Mesh.html">Mesh</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a858a5835e4f070a1d9c01e43785f7224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::createRectangle </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Rect.html">Geometry::Rect_f</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a Rectangle consisting of 2 triangles (oriented in x-y-plane)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td><a class="el" href="structRendering_1_1Vertex.html">Vertex</a> description specifying the vertex information to generate </td></tr>
    <tr><td class="paramname">rect</td><td>the rectangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rectangle <a class="el" href="classRendering_1_1Mesh.html">Mesh</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa354dbf0be329403dfea9ab9ffcfd431"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::createRingSector </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>innerRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>outerRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em> = <code>360.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a sector of a ring. The center of the disc is the origin. The disc is aligned with the y-z plane and the normals are pointing into negative x direction. Positions and normals for the vertices are generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td><a class="el" href="structRendering_1_1Vertex.html">Vertex</a> description specifying the vertex information to generate </td></tr>
    <tr><td class="paramname">innerRadius</td><td>inner radius of the ring </td></tr>
    <tr><td class="paramname">outerRadius</td><td>outer radius of the ring </td></tr>
    <tr><td class="paramname">numSegments</td><td>Number of segments for the disc </td></tr>
    <tr><td class="paramname">angle</td><td>Central angle of the sector in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Disc <a class="el" href="classRendering_1_1Mesh.html">Mesh</a> or <code>nullptr</code> if the number of segments is smaller than two or innerRadius &gt;= outerRadius </dd></dl>

</div>
</div>
<a class="anchor" id="ad0a93bd38b07a030a51b1262173a9cbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::createSphere </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Sphere.html">Geometry::Sphere_f</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inclinationSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>azimuthSegments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a sphere, which is generated by subdividing the sphere surface into segements. The surface is subdivided into the given number of subdivisions of the inclination angle and the azimuth angle, respectively. The sphere is centered at the origin and the vertices are lying on the unit sphere. The given vertex description specifies which information is generated for every vertex. Positions, normals, colors, and texture coordinates are supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td><a class="el" href="structRendering_1_1Vertex.html">Vertex</a> description specifying the vertex information to generate </td></tr>
    <tr><td class="paramname">inclinationSegments</td><td>Number of subdivisions of the inclination angle </td></tr>
    <tr><td class="paramname">azimuthSegments</td><td>Number of subdivisions of the azimuth angle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sphere <a class="el" href="classRendering_1_1Mesh.html">Mesh</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adadf25f0c8138e4a6935841c8d1c1631"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::createTorus </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>innerRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>outerRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>majorSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>minorSegments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a torus mesh. The center of the torus is located at the origin. The aligned is aligned with the x-z plane.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td><a class="el" href="structRendering_1_1Vertex.html">Vertex</a> description specifying the vertex information to generate </td></tr>
    <tr><td class="paramname">innerRadius</td><td>inner radius of the torus. Should be greater than or equal 0. </td></tr>
    <tr><td class="paramname">outerRadius</td><td>outer radius of the torus. Should be greater than inner radius. </td></tr>
    <tr><td class="paramname">majorSegments</td><td>Number of major segments. Minimum is 3. </td></tr>
    <tr><td class="paramname">minorSegments</td><td>Number of minor segments. Minimum is 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mesh </dd></dl>

</div>
</div>
<a class="anchor" id="a53d2a16dc47b680198fd058ccc14202a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::createVoxelMesh </td>
          <td>(</td>
          <td class="paramtype">const VertexDescription &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Util::PixelAccessor &amp;&#160;</td>
          <td class="paramname"><em>colorAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a mesh from a voxel bitmap as exported from a 3D <a class="el" href="classRendering_1_1Texture.html">Texture</a>. The bitmap should have a height of depth*heiht, i.e., each depth layer is stored from top to bottom in the vertical direction of the bitmap. The height and width of the voxel grid is derived from the bitmap width and height. The actual height of the voxel grid is bitmap-height/depth. A voxel box of size 1^3 is created for every pixel with a positive alpha value. The local point (0,0,0) in the resulting mesh corresponds to the (0,0,0) coordinate in the voxel bitmap. To scale the mesh afterwards, use <a class="el" href="namespaceRendering_1_1MeshUtils.html#abfb043b29a9df87557824b650fac0bf0" title="(static) ">MeshUtils::transform</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td><a class="el" href="structRendering_1_1Vertex.html">Vertex</a> description specifying the vertex information to generate </td></tr>
    <tr><td class="paramname">colorAcc</td><td>the bitmap that defines the voxel grid. Every pixel with non-zero alpha value defines a voxel. </td></tr>
    <tr><td class="paramname">the</td><td>depth of the voxel grid. The height of the bitmap should be divisible by this value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cd6217b8751953238845c8a55452ae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::cutMesh </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Plane.html">Geometry::Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>tIndices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>std::numeric_limits&lt;&#160;float&#160;&gt;::epsilon()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Cuts the given mesh along the given plane.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh to be cut </td></tr>
    <tr><td class="paramname">plane</td><td>the cutting plane </td></tr>
    <tr><td class="paramname">tIndices</td><td>list of triangle indices to cut. If empty, the whole mesh is cut. </td></tr>
    <tr><td class="paramname">tolerance</td><td>if a vertex lies on the plane with the given tolerance, no new vertex is created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Sascha Brandt </dd></dl>

</div>
</div>
<a class="anchor" id="a6667024e1595f5b07f07885120181b66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::eliminateDuplicateVertices </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Remove vertices which are equal to each other from the mesh and store them only once. The indices to the vertices are adjusted. This function has runtime O(n * log(n)) where n is the number of vertices in <em>mesh</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> to do the elimination on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Benjamin Eikel </dd></dl>

</div>
</div>
<a class="anchor" id="a78b90a2bab24117ce45c9edaf601aa38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::eliminateLongTriangles </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Deletes long triangles (whose ratio between the longest side and the corresponding height is &gt; ratio). </p>
<dl class="section note"><dt>Note</dt><dd>Calls eliminateUnusedVertices to remove unused vertices. </dd></dl>

</div>
</div>
<a class="anchor" id="a503aa64096c8790c7363112178127e04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::eliminateTrianglesBehindPlane </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Plane.html">Geometry::Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete triangles that have at least one vertex lying behind the given plane.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Source mesh. The mesh is not changed. </td></tr>
    <tr><td class="paramname">plane</td><td>Plane that is used for cutting off vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New mesh </dd></dl>

</div>
</div>
<a class="anchor" id="ad25ea35285043c65f323cfdcb88a2f17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::eliminateUnusedVertices </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Clone the given mesh but remove all vertices which are never referenced. </p>

</div>
</div>
<a class="anchor" id="a8b70017f02f988b6282342a4ae7ad08f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::eliminateZeroAreaTriangles </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete triangles that have (nearly) zero area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Source mesh. The mesh is not changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New mesh </dd></dl>

</div>
</div>
<a class="anchor" id="a710c85b40d1fcd04bf748229840f97e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1MeshVertexData.html">MeshVertexData</a> * Rendering::MeshUtils::extractVertexData </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[static] Extracts a range of vertices from a mesh.</p>
<p>Extracts a range of vertices from the given mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh to extract the vertex data from </td></tr>
    <tr><td class="paramname">begin</td><td>Start of the range of extracted vertices </td></tr>
    <tr><td class="paramname">length</td><td>The number of vertices to extract</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Sascha Brauer </dd></dl>

</div>
</div>
<a class="anchor" id="a77ebb981d3ef49c8d8e0b893f8c198da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1MeshVertexData.html">Rendering::MeshVertexData</a> * Rendering::MeshUtils::extractVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRendering_1_1Mesh.html">Rendering::Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts the vertices of a mesh with corresponding indices and moves them to a new mesh</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> to extract vertices from </td></tr>
    <tr><td class="paramname">indices</td><td>array of indices of the vertices to be extracted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new mesh </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Sascha Brandt </dd></dl>

</div>
</div>
<a class="anchor" id="adcc92acfcc23bb4ecaf3723f51c595d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::extrudeTriangles </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Vec3.html">Geometry::Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>tIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Extrudes the specified triangles of the given mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh </td></tr>
    <tr><td class="paramname">dir</td><td>extrusion direction </td></tr>
    <tr><td class="paramname">tIndices</td><td>set of triangle indices to extrude </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Sascha Brandt </dd></dl>

</div>
</div>
<a class="anchor" id="aa37af463abde9234562387aa3198dc95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::flattenMesh </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Vec3.html">Geometry::Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>falloff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the y-coordinates of all vertices in a radius around a given 3d position to it's y-coordinate (with cubic bezier falloff)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramname">pos</td><td>the 3d position </td></tr>
    <tr><td class="paramname">radius</td><td>radius around the 3d position to flatten vertices </td></tr>
    <tr><td class="paramname">falloff</td><td>blend falloff for vertices beyond the radius </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Sascha Brandt </dd></dl>

</div>
</div>
<a class="anchor" id="aa7f52d8ce06c36a89e9eef2f5d9add66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Rendering::MeshUtils::getFirstTriangleIntersectingRay </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Ray.html">Geometry::Ray3</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Slow method for finding the first triangle in a mesh that intersects the given ray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh </td></tr>
    <tr><td class="paramname">ray</td><td>the ray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if no intersecting triangle was found, the triangle index otherwise. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Sascha Brandt </dd></dl>

</div>
</div>
<a class="anchor" id="a300bc6f309a727483715ac260cfd3a5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Rendering::MeshUtils::getLongestSideLength </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the max. side length of the polygon in the mesh m </p>

</div>
</div>
<a class="anchor" id="aa18e1f3d99e4812f2a11b95dbb8e55f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Rendering::MeshUtils::mergeCloseVertices </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>std::numeric_limits&lt;&#160;float&#160;&gt;::epsilon()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Remove vertices which are close to each other from the mesh and store them only once. The indices to the vertices are adjusted. This function has runtime O(n * log(n)) where n is the number of vertices in <em>mesh</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> to do the elimination on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of merged vertices </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Sascha Brandt </dd></dl>

</div>
</div>
<a class="anchor" id="aff80752e72dbbac45a55e975ac328f82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::optimizeIndices </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint_fast8_t&#160;</td>
          <td class="paramname"><em>cacheSize</em> = <code>24</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take the given mesh and optimize the indices stored there for vertex cache optimality. The implementation is based on the algorithm described by Sander, Nehab and Barczak. This function has runtime O(n) where n is the number of indices in <em>mesh</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> whose indices will be optimized. </td></tr>
    <tr><td class="paramname">cacheSize</td><td>Post-transform vertex cache size to optimize for. This parameter is called <code>k</code> in the article. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a href="http://doi.acm.org/10.1145/1276377.1276489">http://doi.acm.org/10.1145/1276377.1276489</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Benjamin Eikel </dd></dl>
<p>Consider all 1-ring candidates and select the best for fanning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop</td><td>Flag which tells if the algorithm has ended. </td></tr>
    <tr><td class="paramname">nextCand</td><td>Passed from caller. </td></tr>
    <tr><td class="paramname">stamp</td><td>Passed from caller. </td></tr>
    <tr><td class="paramname">cacheSize</td><td>Passed from caller. </td></tr>
    <tr><td class="paramname">cacheTimes</td><td>Passed from caller. </td></tr>
    <tr><td class="paramname">liveTriangles</td><td>Passed from caller. </td></tr>
    <tr><td class="paramname">deadEndStack</td><td>Passed from caller. </td></tr>
    <tr><td class="paramname">numVertices</td><td>Passed from caller. </td></tr>
    <tr><td class="paramname">cursor</td><td>Passed from caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of next vertex.</dd></dl>
<p>When there are no candidates left we might have to choose an non- local vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop</td><td>Flag which tells if the algorithm has ended. </td></tr>
    <tr><td class="paramname">liveTriangles</td><td>Passed from caller. </td></tr>
    <tr><td class="paramname">deadEndStack</td><td>Passed from caller. </td></tr>
    <tr><td class="paramname">numVertices</td><td>Passed from caller. </td></tr>
    <tr><td class="paramname">cursor</td><td>Passed from caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of non-local vertex.</dd></dl>

</div>
</div>
<a class="anchor" id="a79d2c04092e8cdcf06fa7299fc66a1f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::removeColorData </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>removes the color information from a mesh </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh to be modified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ralf Petring </dd></dl>

</div>
</div>
<a class="anchor" id="acb823e3f32f3e353f5dac8c74005b201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * Rendering::MeshUtils::removeSkinsWithHoleCovering </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxNormalZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>coveringMovement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identify triangles that span large depth ranges by calculating their normals. Remove those triangles and move the adjacent vertices in the background a little bit to cover the arising hole.</p>
<dl class="section note"><dt>Note</dt><dd>The calculation assumes that z values represent depth, x values represent horizontal direction, and y values represent vertical direction. This holds for meshes generated from depth textures. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Source mesh. The mesh is not changed. </td></tr>
    <tr><td class="paramname">maxNormalZ</td><td>Maximum absolute z coordinate of the triangle's normal so that the triangle is removed. </td></tr>
    <tr><td class="paramname">coveringMovement</td><td>Ratio of the depth range of the removed triangle that the background vertices are moved in normal direction of this triangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New mesh </dd></dl>
<dl class="section note"><dt>Note</dt><dd>maxNormalZ = 0.6f and coveringMovement = 0.1f are good starting points. </dd></dl>

</div>
</div>
<a class="anchor" id="a9dcd1ea7b19bd34f669ac1a7e7a33457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::reverseWinding </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the order of the vertices of each triangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Input and output mesh (the given mesh is changed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function only works for meshes with a triangle list. If the mesh uses another mode, then the mesh is not changed. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Benjamin Eikel </dd></dl>

</div>
</div>
<a class="anchor" id="a1cdb7b9a052ac2b83c708d5cbf2a4e51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::setColor </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Util::Color4f &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Apply color information to each vertex of the mesh </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>the mesh to be midified </td></tr>
    <tr><td class="paramname">color</td><td>the color to be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ralf Petring </dd></dl>

</div>
</div>
<a class="anchor" id="a192b3d7509cae6ac85ade03de0fba043"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::setMaterial </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Util::Color4f &amp;&#160;</td>
          <td class="paramname"><em>ambient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Util::Color4f &amp;&#160;</td>
          <td class="paramname"><em>diffuse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Util::Color4f &amp;&#160;</td>
          <td class="paramname"><em>specular</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>shininess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Apply material information to each vertex of the mesh </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>the mesh to be midified </td></tr>
    <tr><td class="paramname">ambient</td><td>the ambient color to be set </td></tr>
    <tr><td class="paramname">diffuse</td><td>the diffuse color to be set </td></tr>
    <tr><td class="paramname">specular</td><td>the specular color to be set </td></tr>
    <tr><td class="paramname">shininess</td><td>the shininess value to be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ralf Petring </dd></dl>

</div>
</div>
<a class="anchor" id="a0f0adaa82c3568022fb7fcd818a50d72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::shrinkMesh </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shrinkPosition</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>converts normals from 3 * GL_FLOAT to 4 * GL_BYTE if present converts colors from (3 or 4) * GL_FLOAT to 4 * GL_UNSIGNED_BYTE if present optionally converts position from (3 or 4) * GL_FLOAT to 4 * GL_HALF_FLOAT </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh to be shrinked </td></tr>
    <tr><td class="paramname">@author</td><td>Ralf Petring </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84d89130bebd047c62ad7c80561666ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="classRendering_1_1Mesh.html">Mesh</a> * &gt; Rendering::MeshUtils::splitIntoConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>relDistance</em> = <code>0.001</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splits a mesh into its connected components.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td><a class="el" href="classRendering_1_1Mesh.html">Mesh</a> to split into connected components </td></tr>
    <tr><td class="paramname">relDistance</td><td>relative distance (w.r.t. mesh's bounding box) between vertices that are considered as connected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>connected components of the mesh </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Sascha Brandt </dd></dl>

</div>
</div>
<a class="anchor" id="a515d912a1726ddf51b77069257f8c1ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::splitLargeTriangles </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxSideLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>splits all triangles in the mesh which have at least one side longer than specified </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh to deal with </td></tr>
    <tr><td class="paramname">maxSideLength</td><td>the maximum length of a triangles edge, if this value is exceeded the triangle will be split up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the modified mesh </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ralf Petring </dd></dl>

</div>
</div>
<a class="anchor" id="a74792b5a5d9f3b307079351fd61d96a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="classRendering_1_1MeshVertexData.html">MeshVertexData</a> &gt; Rendering::MeshUtils::splitVertexData </td>
          <td>(</td>
          <td class="paramtype">Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chunkSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[static] Splits a meshs vertex data into several data chunks of the given size.</p>
<p>Splits the vertex data of a given mesh into multiple blocks of vertex data each containing <em>chunkSize</em> many vertices.</p>
<dl class="section note"><dt>Note</dt><dd>The last block only contains MeshVertexCount % chunkSize many vertices. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Sascha Brauer </dd></dl>

</div>
</div>
<a class="anchor" id="abfb043b29a9df87557824b650fac0bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::transform </td>
          <td>(</td>
          <td class="paramtype">MeshVertexData &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Matrix4x4.html">Geometry::Matrix4x4</a> &amp;&#160;</td>
          <td class="paramname"><em>transMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>transforms the position and the normals of the vertices of the vertex data by the given matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>the vertex data to be modified </td></tr>
    <tr><td class="paramname">transMat</td><td>the matrix to be used for transformation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Claudius Jaehn </dd></dl>

</div>
</div>
<a class="anchor" id="a24b90a18ab819edfd7eebd85b7c06cb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rendering::MeshUtils::transformCoordinates </td>
          <td>(</td>
          <td class="paramtype">MeshVertexData &amp;&#160;</td>
          <td class="paramname"><em>vData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Util::StringIdentifier&#160;</td>
          <td class="paramname"><em>attrName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1__Matrix4x4.html">Geometry::Matrix4x4</a> &amp;&#160;</td>
          <td class="paramname"><em>transMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numVerts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(static) </p>
<p>Transforms one specific vertexAttribute of the vertexData according to the given matrix. </p>

</div>
</div>
<a class="anchor" id="ac3755cd140e5d03830999d3f0baeb67c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> Rendering::MeshUtils::uniteVertexDescriptions </td>
          <td>(</td>
          <td class="paramtype">const std::deque&lt; VertexDescription &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexDescs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a new <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> that contains the union of all VertexAttributes of the given VertexDescriptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexDescs</td><td>Container with VertexDescriptions that will be analysed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classRendering_1_1VertexDescription.html">VertexDescription</a> that is able to hold all VertexAttributes. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Benjamin Eikel </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 15 2018 17:04:18 for Rendering by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
