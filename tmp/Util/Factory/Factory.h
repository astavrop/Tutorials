/*
	This file is part of the Util library.
	Copyright (C) 2007-2012 Benjamin Eikel <benjamin@eikel.org>
	Copyright (C) 2007-2012 Claudius JÃ¤hn <claudius@uni-paderborn.de>
	Copyright (C) 2007-2012 Ralf Petring <ralf@petring.net>
	
	This library is subject to the terms of the Mozilla Public License, v. 2.0.
	You should have received a copy of the MPL along with this library; see the 
	file LICENSE. If not, you can obtain one at http://mozilla.org/MPL/2.0/.
*/
#ifndef UTIL_FACTORY_FACTORY_H
#define UTIL_FACTORY_FACTORY_H

#include "FallbackPolicies.h"
#include <functional>
#include <map>

namespace Util {

/**
 * @brief Generic factory for objects
 *
 * The factory template can be instaniated to generate different kinds of factories.
 * The generated factory generates objects of type @a ObjectType.
 *
 * @tparam ObjectType Base type for all objects that are generated by the factory
 * @tparam IdentifierType Type of the identifier that specifies which object creator to call
 * @tparam ObjectCreator Type for callable entities that generate an object of type @a WrapperType
 * @tparam FallbackPolicy Template with a function @a onUnknownType() that handles the case that the requested object type was not found
 * @author Benjamin Eikel
 * @date 2012-02-07
 * @see Patterns from Chapter 8 in Andrei Alexandrescu: Modern C++ Design. Addison-Wesley, 2001.
 */
template < class ObjectType,
		 typename IdentifierType,
		 typename ObjectCreator = std::function<ObjectType ()>,
		 template<class, typename> class FallbackPolicy = FallbackPolicies::ExceptionFallback >
class Factory {
	private:
		typedef std::map<IdentifierType, ObjectCreator> registrations_t;
		registrations_t registrations;
	public:
		typedef FallbackPolicy<ObjectType, IdentifierType> fallbackPolicy_t;
		fallbackPolicy_t fallbackPolicy;
		Factory() : fallbackPolicy() {
		}
		Factory(fallbackPolicy_t policy) : fallbackPolicy(policy) {
		}

		bool registerType(const IdentifierType & id, ObjectCreator creator) {
			return registrations.insert(typename registrations_t::value_type(id, creator)).second;
		}

		bool unregisterType(const IdentifierType & id) {
			return registrations.erase(id);
		}

		ObjectType create(const IdentifierType & id) {
			typename registrations_t::const_iterator it = registrations.find(id);
			if(it != registrations.end()) {
				return (it->second)();
			}
			return fallbackPolicy.onUnknownType(std::bind(&Factory::create, this, std::placeholders::_1), id);
		}
};

/**
 * @brief Generic creator for objects
 *
 * This functor returns a new object of type @a ObjectType.
 *
 * @tparam ObjectType Concrete type of object that will be created
 * @author Benjamin Eikel
 * @date 2012-02-07
 */
template<class ObjectType>
class ObjectCreator {
	public:
		ObjectType * operator()() {
			return new ObjectType();
		}
};

/**
 * @brief Creator for objects that holds a single instance
 *
 * This functor stores a pointer to a single instance of type @a ObjectType.
 * It returns that pointer every time a creation is requested.
 *
 * @tparam ObjectType Concrete type of object that will be pointed to
 * @author Benjamin Eikel
 * @date 2012-02-08
 */
template<class ObjectType>
class PointerHolderCreator {
	private:
		ObjectType * instance;
	public:
		PointerHolderCreator(ObjectType * ptr) : instance(ptr) {
		}
		ObjectType * operator()() {
			return instance;
		}
};

}

#endif /* UTIL_FACTORY_FACTORY_H */
